/*!
 * chart-lite-1.0.0
 * Local, dependency-free Chart.js compatibility shim for dashboard sparklines.
 */
(function (global) {
  'use strict';

  function asArray(value) {
    return Array.isArray(value) ? value : [];
  }

  function asNumber(value) {
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : 0;
  }

  function colorsFor(values, provided) {
    if (Array.isArray(provided) && provided.length > 0) {
      return provided;
    }
    if (typeof provided === 'string' && provided.trim()) {
      return values.map(() => provided);
    }
    return values.map((_value, index) => (index % 2 === 0 ? 'rgba(233, 189, 213, 0.90)' : 'rgba(214, 151, 186, 0.86)'));
  }

  function isDarkMode() {
    try {
      return Boolean(global.matchMedia && global.matchMedia('(prefers-color-scheme: dark)').matches);
    } catch (_e) {
      return false;
    }
  }

  function axisColor() {
    return isDarkMode() ? 'rgba(229, 217, 226, 0.72)' : 'rgba(88, 72, 82, 0.62)';
  }

  function axisGridColor() {
    return isDarkMode() ? 'rgba(229, 217, 226, 0.24)' : 'rgba(88, 72, 82, 0.16)';
  }

  function axisLabelColor() {
    return isDarkMode() ? 'rgba(245, 236, 243, 0.92)' : 'rgba(64, 52, 60, 0.90)';
  }

  function chartHoleColor(ctx) {
    try {
      const canvas = ctx && ctx.canvas ? ctx.canvas : null;
      if (canvas && canvas.parentElement && global.getComputedStyle) {
        const panelBg = global.getComputedStyle(canvas.parentElement).backgroundColor;
        if (panelBg && panelBg !== 'transparent' && panelBg !== 'rgba(0, 0, 0, 0)') {
          return panelBg;
        }
      }
    } catch (_e) {
      // Fall through to deterministic fallback.
    }
    return isDarkMode() ? 'rgba(44, 36, 48, 1)' : '#ffffff';
  }

  function asLabelList(rawLabels, count) {
    const labels = asArray(rawLabels).map((entry) => String(entry || '').trim());
    while (labels.length < count) {
      labels.push('Item ' + String(labels.length + 1));
    }
    return labels.slice(0, count);
  }

  function truncateLabel(label, maxLength) {
    const text = String(label || '');
    if (text.length <= maxLength) return text;
    return text.slice(0, Math.max(1, maxLength - 1)) + 'â€¦';
  }

  function prepareCanvas(ctx) {
    const canvas = ctx && ctx.canvas ? ctx.canvas : null;
    if (!canvas) return { width: 0, height: 0 };
    const dpr = Math.max(1, global.devicePixelRatio || 1);
    const width = Math.max(1, Math.floor(canvas.clientWidth || canvas.width || 300));
    const height = Math.max(1, Math.floor(canvas.clientHeight || canvas.height || 150));
    const targetWidth = Math.floor(width * dpr);
    const targetHeight = Math.floor(height * dpr);
    if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
      canvas.width = targetWidth;
      canvas.height = targetHeight;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, width, height);
    return { width, height };
  }

  function drawEmptyState(ctx, size, message) {
    ctx.save();
    ctx.fillStyle = 'rgba(90, 90, 90, 0.60)';
    ctx.font = '12px ui-sans-serif, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(message, size.width / 2, size.height / 2);
    ctx.restore();
  }

  function drawDoughnut(ctx, size, data, style, labels) {
    const values = asArray(data).map(asNumber);
    const total = values.reduce((sum, value) => (value > 0 ? sum + value : sum), 0);
    if (values.length === 0 || total <= 0) {
      drawEmptyState(ctx, size, 'No chart data');
      return;
    }

    const legendLabels = asLabelList(labels, values.length);
    const legendColumns = legendLabels.length > 4 ? 2 : 1;
    const legendRows = legendLabels.length === 0 ? 0 : Math.ceil(legendLabels.length / legendColumns);
    const legendHeight = legendRows > 0 ? (legendRows * 18) + 12 : 0;
    const chartHeight = Math.max(64, size.height - legendHeight);
    const palette = colorsFor(values, style);
    const outer = Math.max(20, Math.floor(Math.min(size.width, chartHeight) * 0.34));
    const inner = Math.max(8, Math.floor(outer * 0.62));
    const centerX = Math.floor(size.width / 2);
    const centerY = Math.floor(chartHeight / 2);

    let start = -Math.PI / 2;
    values.forEach((value, index) => {
      if (value <= 0) return;
      const end = start + ((value / total) * Math.PI * 2);
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.fillStyle = palette[index] || 'rgba(225, 175, 205, 0.9)';
      ctx.arc(centerX, centerY, outer, start, end);
      ctx.closePath();
      ctx.fill();
      start = end;
    });

    ctx.beginPath();
    ctx.fillStyle = chartHoleColor(ctx);
    ctx.arc(centerX, centerY, inner, 0, Math.PI * 2);
    ctx.fill();

    if (legendRows > 0) {
      const legendTop = chartHeight + 6;
      const legendColumnWidth = Math.max(120, Math.floor((size.width - 24) / legendColumns));
      ctx.save();
      ctx.font = '11px ui-sans-serif, system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      legendLabels.forEach((label, index) => {
        const row = Math.floor(index / legendColumns);
        const column = index % legendColumns;
        const x = 12 + (column * legendColumnWidth);
        const y = legendTop + (row * 18);
        ctx.fillStyle = palette[index] || 'rgba(225, 175, 205, 0.9)';
        ctx.fillRect(x, y - 4, 8, 8);
        ctx.fillStyle = axisLabelColor();
        ctx.fillText(truncateLabel(label, 20), x + 12, y);
      });
      ctx.restore();
    }
  }

  function drawBars(ctx, size, values, style, labels) {
    const max = Math.max(1, ...values);
    const axisLeft = 42;
    const axisBottom = size.height - 24;
    const usableWidth = Math.max(10, size.width - axisLeft - 8);
    const usableHeight = Math.max(20, axisBottom - 10);
    const slot = usableWidth / Math.max(1, values.length);
    const barWidth = Math.max(2, Math.floor(slot * 0.78));
    const palette = colorsFor(values, style);
    const chartLabels = asLabelList(labels, values.length);
    const xLabelStep = Math.max(1, Math.ceil(chartLabels.length / 6));

    ctx.save();
    ctx.strokeStyle = axisColor();
    ctx.lineWidth = 1.1;
    ctx.beginPath();
    ctx.moveTo(axisLeft, 10);
    ctx.lineTo(axisLeft, axisBottom);
    ctx.lineTo(size.width - 4, axisBottom);
    ctx.stroke();

    const yTicks = [0, Math.round(max / 2), max];
    ctx.font = '11px ui-sans-serif, system-ui, sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    yTicks.forEach((tick) => {
      const ratio = tick / max;
      const y = axisBottom - (ratio * usableHeight);
      ctx.strokeStyle = axisGridColor();
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(axisLeft, y);
      ctx.lineTo(size.width - 4, y);
      ctx.stroke();
      ctx.fillStyle = axisLabelColor();
      ctx.fillText(String(tick), axisLeft - 6, y);
    });

    values.forEach((value, index) => {
      const ratio = value / max;
      const height = Math.max(1, Math.floor(ratio * usableHeight));
      const x = axisLeft + (index * slot) + Math.max(0, Math.floor((slot - barWidth) / 2));
      const y = axisBottom - height;
      ctx.fillStyle = palette[index] || 'rgba(225, 175, 205, 0.9)';
      ctx.fillRect(x, y, barWidth, height);
    });

    ctx.fillStyle = axisLabelColor();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    chartLabels.forEach((label, index) => {
      if (index % xLabelStep !== 0 && index !== chartLabels.length - 1) return;
      const x = axisLeft + (index * slot) + (slot / 2);
      ctx.fillText(truncateLabel(label, 12), x, axisBottom + 6);
    });
    ctx.restore();
  }

  function drawLine(ctx, size, values, style, labels) {
    const max = Math.max(1, ...values);
    const left = 42;
    const top = 12;
    const right = size.width - 10;
    const bottom = size.height - 24;
    const width = Math.max(10, right - left);
    const height = Math.max(20, bottom - top);
    const step = values.length > 1 ? width / (values.length - 1) : width;
    const chartLabels = asLabelList(labels, values.length);
    const xLabelStep = Math.max(1, Math.ceil(chartLabels.length / 6));
    const points = values.map((value, index) => ({
      x: left + (index * step),
      y: bottom - ((value / max) * height)
    }));

    ctx.save();
    const gradient = ctx.createLinearGradient(0, top, 0, bottom);
    gradient.addColorStop(0, 'rgba(246, 220, 236, 0.94)');
    gradient.addColorStop(1, 'rgba(228, 180, 207, 0.72)');
    ctx.beginPath();
    ctx.moveTo(points[0].x, bottom);
    points.forEach((point) => {
      ctx.lineTo(point.x, point.y);
    });
    ctx.lineTo(points[points.length - 1].x, bottom);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    points.slice(1).forEach((point) => {
      ctx.lineTo(point.x, point.y);
    });
    ctx.strokeStyle = (style && style[0]) || 'rgba(204, 137, 170, 0.95)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.strokeStyle = axisColor();
    ctx.lineWidth = 1.1;
    ctx.beginPath();
    ctx.moveTo(left, top);
    ctx.lineTo(left, bottom);
    ctx.lineTo(right, bottom);
    ctx.stroke();

    const yTicks = [0, Math.round(max / 2), max];
    ctx.font = '11px ui-sans-serif, system-ui, sans-serif';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    yTicks.forEach((tick) => {
      const ratio = tick / max;
      const y = bottom - (ratio * height);
      ctx.strokeStyle = axisGridColor();
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();
      ctx.fillStyle = axisLabelColor();
      ctx.fillText(String(tick), left - 6, y);
    });

    ctx.fillStyle = axisLabelColor();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    chartLabels.forEach((label, index) => {
      if (index % xLabelStep !== 0 && index !== chartLabels.length - 1) return;
      const x = left + (index * step);
      ctx.fillText(truncateLabel(label, 12), x, bottom + 6);
    });
    ctx.restore();
  }

  function ChartLite(ctx, config) {
    this.ctx = ctx;
    this.canvas = ctx && ctx.canvas ? ctx.canvas : null;
    this.type = String((config && config.type) || 'bar');
    this.data = (config && config.data) || { labels: [], datasets: [{ data: [] }] };
    this.options = (config && config.options) || {};
    this.update();
  }

  ChartLite.prototype.update = function update() {
    if (!this.ctx || !this.canvas) return;
    const size = prepareCanvas(this.ctx);
    if (size.width <= 0 || size.height <= 0) return;

    const dataset = asArray(this.data.datasets)[0] || {};
    const values = asArray(dataset.data).map(asNumber);
    const style = dataset.backgroundColor || dataset.borderColor;
    const labels = asArray(this.data.labels).map((entry) => String(entry || ''));

    if (values.length === 0) {
      drawEmptyState(this.ctx, size, 'No chart data');
      return;
    }

    if (this.type === 'doughnut') {
      drawDoughnut(this.ctx, size, values, style, labels);
      return;
    }
    if (this.type === 'line') {
      drawLine(this.ctx, size, values, asArray(style), labels);
      return;
    }
    drawBars(this.ctx, size, values, asArray(style), labels);
  };

  global.Chart = ChartLite;
})(window);
